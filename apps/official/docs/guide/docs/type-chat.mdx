# AI å·¥ç¨‹åŒ–

**æŒ‘æˆ˜**

å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰çš„å´›èµ·æ— ç–‘ä¸ºè‡ªç„¶è¯­è¨€å¤„ç†ï¼ˆNLPï¼‰é¢†åŸŸå¸¦æ¥äº†å·¨å¤§çš„å˜é©ã€‚è¿™äº›æ¨¡å‹å‡­å€Ÿæµ·é‡çš„æ•°æ®å’Œå¤æ‚çš„ç¥ç»ç½‘ç»œç»“æ„ï¼Œå±•ç°å‡ºäº†å¼ºå¤§çš„è¯­è¨€ç†è§£å’Œç”Ÿæˆèƒ½åŠ›ã€‚ç„¶è€Œï¼Œå°½ç®¡å¤§æ¨¡å‹åœ¨æ–‡æœ¬ç”Ÿæˆã€é—®ç­”ç­‰ä»»åŠ¡ä¸­è¡¨ç°å‡ºè‰²ï¼Œä½†å…¶è¿”å›çš„è‡ªç„¶è¯­è¨€å½¢å¼å´éš¾ä»¥è¢«åº”ç”¨ç¨‹åºç›´æ¥ä½¿ç”¨ï¼Œè¿™æˆä¸ºäº† AI å·¥ç¨‹åŒ–è¿‡ç¨‹ä¸­çš„ä¸€å¤§æŒ‘æˆ˜ã€‚

**æ¨¡å¼å·¥ç¨‹**

C#ã€TypeScript ä¹‹çˆ¶ Anders Hejlsberg å¼€æºçš„ TypeChat é¡¹ç›®ï¼Œé€šè¿‡ä½¿ç”¨æ¨¡å¼å·¥ç¨‹ä»£æ›¿ä¼ ç»Ÿçš„æç¤ºå·¥ç¨‹ç»™å‡ºäº†ä¸€ä¸ªè§£å†³æ–¹æ¡ˆã€‚TypeChat çš„æ ¸å¿ƒåŸç†åœ¨äºå…¶æ¨¡å¼å·¥ç¨‹çš„æ–¹æ³•ã€‚å®ƒå…è®¸å¼€å‘è€…è‡ªç”±å®šä¹‰ç±»å‹ï¼Œä»¥å‡†ç¡®è¡¨è¾¾è‡ªç„¶è¯­è¨€åº”ç”¨ç¨‹åºæ‰€æ”¯æŒçš„æ„å›¾ã€‚ä¸€æ—¦å®šä¹‰äº†è¿™äº›ç±»å‹ï¼ŒTypeChat ä¼šä¸º LLM åˆ¶å®šæç¤ºï¼Œå¹¶éªŒè¯ LLM çš„å“åº”æ˜¯å¦ç¬¦åˆæ¨¡å¼ã€‚å½“éªŒè¯å¤±è´¥æ—¶ï¼ŒTypeChat ä¼šè¿›è¡Œé¢å¤–çš„è¯­è¨€æ¨¡å‹äº¤äº’ï¼Œä»¥ä¿®å¤ä¸ç¬¦åˆè¦æ±‚çš„è¾“å‡ºã€‚è¿™ç§æœºåˆ¶ç¡®ä¿äº† TypeChat èƒ½å¤Ÿç”Ÿæˆç¬¦åˆåº”ç”¨ç¨‹åºéœ€æ±‚çš„å“åº”ç»“æœï¼Œä»è€Œå®ç°äº† AI ä¸åº”ç”¨ç¨‹åºçš„ååŒå·¥ä½œã€‚

é€šä¿—çš„æ¥è®²å°±æ˜¯åœ¨æ¯æ¬¡å‘å¤§æ¨¡å‹æé—®çš„æ—¶å€™è¦æ±‚å®ƒæŒ‰ç…§æŒ‡å®šçš„ç±»å‹è¿”å› JSON æ•°æ®ï¼Œå¦‚æœè¿”å›çš„æ•°æ®ä¸ç¬¦åˆä½ ç»™å‡ºçš„ç±»å‹å®šä¹‰ï¼ŒæŠŠé”™è¯¯ä¿¡æ¯å‘Šè¯‰å®ƒè®©ä»–ä¿®å¤ä¹‹åé‡æ–°è¿”å›ï¼Œæœ€åå°†éªŒè¯é€šè¿‡åçš„ JSON æ•°æ®å›ç»™åº”ç”¨ç¨‹åºã€‚

è¿™æ˜¯ä¸€ä¸ªä½¿ç”¨ TypeChat ç¼–å†™çš„æƒ…æ„Ÿåˆ†ç±»å™¨ï¼Œå®ƒå°†ç”¨æˆ·è¾“å…¥åˆ†ç±»ä¸ºæ¶ˆæã€ä¸­æ€§æˆ–ç§¯æ:

```typescript
// sentimentSchema.ts
export interface SentimentResponse {
  sentiment: 'æ¶ˆæçš„' | 'ä¸­æ€§çš„' | 'ç§¯æçš„';
}
```

```typescript
import assert from 'assert';
import dotenv from 'dotenv';
import findConfig from 'find-config';
import fs from 'fs';
import path from 'path';
import { createJsonTranslator, createLanguageModel } from 'typechat';
import { processRequests } from 'typechat/interactive';
import { createTypeScriptJsonValidator } from 'typechat/ts';
import { SentimentResponse } from './sentimentSchema';

const dotEnvPath = findConfig('.env');
assert(dotEnvPath, '.env file not found!');
dotenv.config({ path: dotEnvPath });

const model = createLanguageModel(process.env);
// å°†æ¨¡å¼å®šä¹‰çš„æºæ–‡ä»¶å†…å®¹ç”¨äºæ„å»ºæç¤ºè¯
const schema = fs.readFileSync(path.join(__dirname, 'sentimentSchema.ts'), 'utf8');
const validator = createTypeScriptJsonValidator<SentimentResponse>(schema, 'SentimentResponse');
const translator = createJsonTranslator(model, validator);

processRequests('ğŸ˜€> ', process.argv[2], async request => {
  const response = await translator.translate(request);
  if (!response.success) {
    console.log(response.message);
    return;
  }
  console.log(`ç”¨æˆ·çš„æƒ…ç»ªæ˜¯ ${response.data.sentiment}`);
});

// è¾“å…¥ TypeChat çœŸæ£’!

// è¾“å‡º ç”¨æˆ·æƒ…ç»ªæ˜¯ ç§¯æçš„
```

æ ¸å¿ƒä»£ç é€»è¾‘å¦‚ä¸‹:

```typescript
async function translate(request: string, promptPreamble?: string | PromptSection[]) {
  const preamble: PromptSection[] =
    typeof promptPreamble === 'string' ? [{ role: 'user', content: promptPreamble }] : promptPreamble ?? [];

  let prompt: PromptSection[] = [...preamble, { role: 'user', content: typeChat.createRequestPrompt(request) }];

  let attemptRepair = typeChat.attemptRepair;

  // è¿›å…¥ä¸€ä¸ªæ— é™å¾ªç¯ï¼Œç›´åˆ°å¾—åˆ°æœ‰æ•ˆçš„å“åº”æˆ–ä¿®å¤å¤±è´¥
  while (true) {
    // ä½¿ç”¨æ¨¡å‹å®Œæˆpromptï¼Œå¹¶ç­‰å¾…å…¶å“åº”
    const response = await model.complete(prompt);

    // å¦‚æœå“åº”ä¸æˆåŠŸï¼Œç›´æ¥è¿”å›å“åº”
    if (!response.success) {
      return response;
    }

    // è·å–å“åº”çš„æ–‡æœ¬å†…å®¹
    const responseText = response.data;

    // æŸ¥æ‰¾å“åº”æ–‡æœ¬ä¸­JSONçš„å¼€å§‹å’Œç»“æŸç´¢å¼•
    const startIndex = responseText.indexOf('{');
    const endIndex = responseText.lastIndexOf('}');

    // å¦‚æœå“åº”æ–‡æœ¬ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼ï¼Œè¿”å›é”™è¯¯
    if (!(startIndex >= 0 && endIndex > startIndex)) {
      return error(`Response is not JSON:\n${responseText}`);
    }

    // æå–JSONæ–‡æœ¬
    const jsonText = responseText.slice(startIndex, endIndex + 1);

    // å°è¯•å°†JSONæ–‡æœ¬è§£æä¸ºå¯¹è±¡
    let jsonObject;
    try {
      jsonObject = JSON.parse(jsonText) as object;
    } catch (e) {
      // å¦‚æœè§£æå¤±è´¥ï¼Œè¿”å›é”™è¯¯
      return error(e instanceof SyntaxError ? e.message : 'JSON parse error');
    }

    // å¦‚æœTypeChatè®¾ç½®äº†stripNullsï¼Œåˆ™å»é™¤jsonObjectä¸­çš„nullå€¼
    if (typeChat.stripNulls) {
      stripNulls(jsonObject);
    }

    // ä½¿ç”¨validatorå¯¹jsonObjectè¿›è¡Œæ¨¡å¼éªŒè¯
    const schemaValidation = validator.validate(jsonObject);

    // å¦‚æœæ¨¡å¼éªŒè¯æˆåŠŸï¼Œåˆ™è¿›ä¸€æ­¥ä½¿ç”¨TypeChatè¿›è¡Œå®ä¾‹éªŒè¯
    const validation = schemaValidation.success ? typeChat.validateInstance(schemaValidation.data) : schemaValidation;

    // å¦‚æœéªŒè¯æˆåŠŸï¼Œè¿”å›éªŒè¯ç»“æœ
    if (validation.success) {
      return validation;
    }

    // å¦‚æœä¸å…è®¸ä¿®å¤æˆ–ä¿®å¤å¤±è´¥ï¼Œè¿”å›é”™è¯¯
    if (!attemptRepair) {
      return error(`JSON validation failed: ${validation.message}\n${jsonText}`);
    }

    // å¦‚æœå…è®¸ä¿®å¤ï¼Œå°†å“åº”æ–‡æœ¬å’Œä¿®å¤æç¤ºæ·»åŠ åˆ°promptä¸­
    prompt.push({ role: 'assistant', content: responseText });
    prompt.push({ role: 'user', content: typeChat.createRepairPrompt(validation.message) });

    // ç¦ç”¨ä¸‹ä¸€æ¬¡çš„ä¿®å¤å°è¯•
    attemptRepair = false;
  }
}
```

**æ€»ç»“**

TypeChat å……å½“äº†è‡ªç„¶è¯­è¨€ã€åº”ç”¨æ¨¡å¼å’Œ API ä¹‹é—´çš„æ¡¥æ¢ï¼Œç®€åŒ–äº†å¼€å‘è¿‡ç¨‹å¹¶è§£å†³äº†åº”ç”¨ç¨‹åºä¸å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰çš„é›†æˆé—®é¢˜ã€‚å®ƒä½¿ç”¨äº†ä¸€ç§åˆ›æ–°çš„æ¨¡å¼å·¥ç¨‹æ–¹æ³•ï¼Œå–ä»£äº†ä¼ ç»Ÿçš„æç¤ºå·¥ç¨‹æ–¹æ³•ã€‚å¼€å‘è€…å¯ä»¥è‡ªç”±å®šä¹‰ç±»å‹ï¼Œå‡†ç¡®è¡¨è¾¾è‡ªç„¶è¯­è¨€åº”ç”¨ç¨‹åºæ‰€æ”¯æŒçš„æ„å›¾ã€‚
